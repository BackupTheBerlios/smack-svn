/*
 *  Smack gui, the gui is made up of these seperate drum entries, 
 *  pass null terminated name/param/param number tupels. 
 */
requires 2.0.0
%h{
#include <gtk/gtkvbox.h>
#include "lo/lo.h"
%}



%{
#include "gui-drum.h"
#include "gui.h"
#include "phat-fan-slider-pix.h"
#include <stdio.h>
#include <glib.h>
#include <stdarg.h>

lo_address addr;
%}

class gui:Drum from Gtk:VBox 
{
         
    init (self)
    {	  

    }

    /* this isn't to be used directly*/
    public GtkWidget* new (void)
    {
	return (GtkWidget *)GET_NEW;
    }

    public
    GtkWidget *
    new_drum (const char* title, char* filename, char* drumname, int note, lo_address address, ...)
    {
	va_list ap;
	va_start(ap, address);
	addr = address;
	GtkWidget* widget = (GtkWidget *)GET_NEW;
	GtkWidget* hbox;
	GtkWidget* slider;
	GtkWidget* label;
	GtkWidget* check;
	char* name;

	gtk_box_set_spacing(GTK_BOX(widget), 0);
	hbox = gtk_hbox_new(FALSE, GUI_SPACING);
	gtk_widget_show(hbox);	
	/* the name of this drum, goes at the top */
	label = gtk_label_new(title);
        gtk_label_set_markup(GTK_LABEL(label), g_strconcat("<b>", title, "</b>", NULL));	
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_widget_show(label);
	check = gtk_check_button_new();
	gtk_box_pack_start(GTK_BOX(hbox), check, FALSE, FALSE, 0);
	gtk_widget_show(check);
	g_signal_connect (G_OBJECT (check), "toggled", G_CALLBACK (gui_drum_load_cb), filename);
	gtk_box_pack_start(GTK_BOX(widget), hbox, FALSE, FALSE, 10);

	/* midi note selector 
	label = gtk_label_new("Note");
        gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 0);
	gtk_widget_show(label);

	button = phat_slider_button_new_with_range(note, 0, 127, 1, "%.0f");
	phat_slider_button_set_threshold(PHAT_SLIDER_BUTTON(button), GUI_THRESHOLD);
	gtk_box_pack_start(GTK_BOX(widget), button, FALSE, FALSE, 0);
	gtk_widget_show(button); */

	/* velocity sensitivity 
	label = gtk_label_new("Vel. Sens.");  
	gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 0);
	gtk_widget_show(label); */
	    
	while((name = va_arg(ap, char*)) != NULL)
	{
	    
	    label = gtk_label_new(name);  
	    gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 0);
	    gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
	    gtk_widget_show(label);


	    
	    /* loop over each param creating a slider for it */  
	    slider = phat_fan_slider_pix_new_with_range(.5, 0.0, 1.0, .1);
	    gtk_box_pack_start(GTK_BOX(widget), slider, FALSE, FALSE, 0); 
	    gtk_widget_show(slider);

	    	    
	    gtk_object_set_data(GTK_OBJECT(slider), "drum_name", drumname);
	    gtk_object_set_data(GTK_OBJECT(slider), "param_name", va_arg(ap, char*));
	    gtk_object_set_data(GTK_OBJECT(slider), "param_num", GINT_TO_POINTER(va_arg(ap, int))); 
	     
	    /* connect change parm to osc */
	    g_signal_connect (G_OBJECT (slider), "value-changed", G_CALLBACK (gui_drum_osc_cb), NULL);
	    
	}
	
	  
	  gtk_widget_set_size_request(widget, 85, -1);

	return widget;
    }

    private gint
    osc_cb(GtkWidget* widget, gpointer data)
    {
	if (lo_send(addr, "/patch/set_control", "ssif", gtk_object_get_data(GTK_OBJECT(widget), "drum_name"), gtk_object_get_data(GTK_OBJECT(widget), "param_name"), gtk_object_get_data(GTK_OBJECT(widget), "param_num"), phat_fan_slider_get_value(PHAT_FAN_SLIDER (widget))) == -1) {
	    printf("OSC error %d: %s\n", lo_address_errno(addr), lo_address_errstr(addr));
	}
	fprintf(stderr, "frobing the knobs %s \n", (char*) gtk_object_get_data(GTK_OBJECT(widget), "drum_name"));
	return TRUE;
    }

    /* load the patch by calling om_patch_loader, currently dodgy for some reason... */
    private gint
    load_cb(GtkWidget* widget, gpointer data)
    {
	GError   *error = NULL;
	gchar   *command;
	fprintf(stderr, "filename is right? %s \n", (gchar*) data);
	command = g_strconcat("om_patch_loader -u osc.udp://localhost:19383/ ", (gchar*) data, NULL);
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) /* load patch */
	{
	    if (!g_spawn_command_line_async(command, &error)){
		g_warning("g_spawn_async_with_pipes() failed: %s\n", error->message);
		g_error_free(error);
		error = NULL;
		return 0;
	    }
	} 
	 else
	{
	    //if (lo_send(addr, "/destroy_patch", "is", 
	}    
	
	g_free(command);	 
	return TRUE;
    }

}






