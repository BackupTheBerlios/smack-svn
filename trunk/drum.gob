/*
 *  Smack gui, the gui is made up of these seperate drum entries, 
 *  pass null terminated name/low bound/high bound/param/param name 
 */
requires 2.0.0
%h{
#include <gtk/gtkvbox.h>
#include "lo/lo.h"
%}



%{
#include "gui-drum.h"
#include "gui.h"
#include "phat-fan-slider-pix.h"
#include <stdio.h>
#include <glib.h>
#include <stdlib.h>
#include <stdarg.h>

lo_address addr;
%}

class gui:Drum from Gtk:VBox 
{
         
    init (self)
    {	  

    }

    /* this isn't to be used directly*/
    public GtkWidget* new (void)
    {
	return (GtkWidget *)GET_NEW;
    }

    public
    GtkWidget *
    new_drum (const char* title, char* filename, char* drumname, int note, GHashTable* sliders, lo_address address, ...)
    {
	va_list ap;
	va_start(ap, address);
	addr = address;
	GtkWidget* widget = (GtkWidget *)GET_NEW;
	GtkWidget* hbox;
	GtkWidget* slider;
	GtkWidget* label;
	GtkWidget* check;
	int i = 0;
	double lower, upper;
	char* name;
	char* key;
	
	gtk_box_set_spacing(GTK_BOX(widget), 0);
	hbox = gtk_hbox_new(FALSE, GUI_SPACING);
	gtk_widget_show(hbox);	
	/* the name of this drum, goes at the top */
	label = gtk_label_new(title);
        gtk_label_set_markup(GTK_LABEL(label), g_strconcat("<b>", title, "</b>", NULL));	
	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
	gtk_widget_show(label);
	check = gtk_check_button_new();
	gtk_box_pack_start(GTK_BOX(hbox), check, FALSE, FALSE, 0);
	gtk_widget_show(check);
	gtk_object_set_data(GTK_OBJECT(check), "drum_name", drumname);
	gtk_object_set_data(GTK_OBJECT(check), "file_name", filename);
	gtk_box_pack_start(GTK_BOX(widget), hbox, FALSE, FALSE, 10);

	/* midi note selector 
	label = gtk_label_new("Note");
        gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 0);
	gtk_widget_show(label);

	button = phat_slider_button_new_with_range(note, 0, 127, 1, "%.0f");
	phat_slider_button_set_threshold(PHAT_SLIDER_BUTTON(button), GUI_THRESHOLD);
	gtk_box_pack_start(GTK_BOX(widget), button, FALSE, FALSE, 0);
	gtk_widget_show(button); */

	/* velocity sensitivity 
	label = gtk_label_new("Vel. Sens.");  
	gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 0);
	gtk_widget_show(label); */
	    
	while((name = va_arg(ap, char*)) != NULL)
	{
	    
	    label = gtk_label_new(name);  
	    gtk_box_pack_start(GTK_BOX(widget), label, FALSE, FALSE, 0);
	    gtk_misc_set_alignment(GTK_MISC(label), 0, 0.5);
	    gtk_widget_show(label);
	    lower = va_arg(ap, double);
	    upper = va_arg(ap, double);
	    

	    
	    /* loop over each param creating a slider for it */  
	    slider = phat_fan_slider_pix_new_with_range(0, lower, upper, 0.1);
	    gtk_box_pack_start(GTK_BOX(widget), slider, FALSE, FALSE, 0); 
	    gtk_widget_show(slider);

	    	    
	    gtk_object_set_data(GTK_OBJECT(slider), "drum_name", drumname);
	    gtk_object_set_data(GTK_OBJECT(slider), "node_name", va_arg(ap, char*));
	    gtk_object_set_data(GTK_OBJECT(slider), "param_name", va_arg(ap, char*));
	   	    
	    key=g_strconcat("/", drumname, "/", gtk_object_get_data(GTK_OBJECT(slider), "node_name"), "/", gtk_object_get_data(GTK_OBJECT(slider), "param_name"), NULL);
	    gtk_object_set_data(GTK_OBJECT(slider), "key", key);
	    fprintf(stderr, "add the keys is %s \n", key);  
	    g_hash_table_insert (sliders, key, slider); 
	    /* connect change parm to osc */
	    g_signal_connect (slider, "value-changed", G_CALLBACK (gui_drum_osc_cb), NULL);
	    i++;
	}
	
	gtk_object_set_data(GTK_OBJECT(check), "param_num", GINT_TO_POINTER(i));
	g_signal_connect (G_OBJECT (check), "toggled", G_CALLBACK (gui_drum_load_cb), filename);

 
	gtk_widget_set_size_request(widget, 85, -1);

	return widget;
    }

    private gint
    osc_cb(GtkWidget* widget, gpointer data)
    {
	if (lo_send(addr, "/om/synth/set_port_value", "isf", 42, (gchar*) gtk_object_get_data(GTK_OBJECT(widget), "key"), phat_fan_slider_get_value(PHAT_FAN_SLIDER (widget))) == -1) {
	    printf("OSC error %d: %s\n", lo_address_errno(addr), lo_address_errstr(addr));
	}
	return TRUE;
    }

    /* load the patch by calling om_patch_loader or if loaded unload it. */
    private gint
    load_cb(GtkWidget* widget, gpointer data)
    {
	
	GError   *error = NULL;
	gchar   *command;
	
	
	command = g_strconcat("om_patch_loader -u osc.udp://localhost:16180/ " PKGDATADIR, "/", (gchar*) gtk_object_get_data(GTK_OBJECT(widget), "file_name"), NULL);
	if(gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget))) /* load patch */
	{
	    if (!g_spawn_command_line_async(command, &error)){
		g_warning("g_spawn_async_with_pipes() failed: %s\n", error->message);
		g_error_free(error);
		error = NULL;
		return 0;
	    }
	   	    
	} 
	 else
	{
	    if (lo_send(addr, "/om/synth/destroy_patch", "is", 42, gtk_object_get_data(GTK_OBJECT(widget), "drum_name"))
		        == -1){
		printf("OSC error %d: %s\n", lo_address_errno(addr), lo_address_errstr(addr));
	    }
	}    
	
	g_free(command);	 
	return TRUE;
    }

}






